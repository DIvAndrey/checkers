#[inline(always)]
pub fn get_bit(x: u64, i: i8) -> u64 {
    (x >> i) & 1
}

#[inline(always)]
pub fn after_bit(mask: u64) -> u64 {
    mask - 1
}

#[inline(always)]
pub fn before_bit(mask: u64) -> u64 {
    !(mask ^ (mask - 1))
}

#[inline(always)]
pub fn last_bit(x: u64) -> u64 {
    x & x.wrapping_neg()
}

#[inline(always)]
pub fn first_bit(x: u64) -> u64 {
    #[cfg(debug_assertions)]
    assert_ne!(x, 0);
    0x8000_0000_0000_0000u64.wrapping_shr(x.leading_zeros())
}

#[inline(always)]
pub fn first_bit_or_0(x: u64) -> u64 {
    // last_bit(x.reverse_bits()).reverse_bits()
    x & 0x8000_0000_0000_0000u64.wrapping_shr(x.leading_zeros())
}

#[inline(always)]
pub fn get_bit_i(mask: u64) -> i8 {
    if mask == 0 {
        return 0;
    }
    mask.trailing_zeros() as i8
}

#[inline(always)]
pub fn get_bit_i_or(mask: u64, val: i8) -> i8 {
    if mask == 0 {
        return val;
    }
    return get_bit_i(mask);
}

#[inline(always)]
pub fn conv_1d_to_2d(i: i8) -> (usize, usize) {
    #[cfg(debug_assertions)]
    {
        assert!(i >= 0, "i = {}", i);
        assert!(i < 64, "i = {}", i);
    }
    ((7 - (i & 0b111)) as usize, (7 - i / 8) as usize)
}

#[inline(always)]
pub fn conv_1d_to_2d_i8(i: i8) -> (i8, i8) {
    #[cfg(debug_assertions)]
    {
        assert!(i >= 0, "i = {}", i);
        assert!(i < 64, "i = {}", i);
    }
    ((7 - (i & 0b111)), (7 - (i >> 3)))
}

#[inline(always)]
pub fn conv_2d_to_1d(x: usize, y: usize) -> i8 {
    let i = 63 - x as i8 - 8 * y as i8;
    #[cfg(debug_assertions)]
    {
        assert!(i >= 0, "i = {}", i);
        assert!(i < 64, "i = {}", i);
    }
    i
}


pub const EXCLUDE_RIGHT_COLUMN: u64 = 0b_1111_1110___1111_1110___1111_1110___1111_1110___1111_1110___1111_1110___1111_1110___1111_1110;
pub const EXCLUDE_LEFT_COLUMN: u64 =  0b_0111_1111___0111_1111___0111_1111___0111_1111___0111_1111___0111_1111___0111_1111___0111_1111;
pub const EXCLUDE_2_RIGHT_COLUMNS: u64 = 0b_1111_1100___1111_1100___1111_1100___1111_1100___1111_1100___1111_1100___1111_1100___1111_1100;
pub const EXCLUDE_2_LEFT_COLUMNS: u64 =  0b_0011_1111___0011_1111___0011_1111___0011_1111___0011_1111___0011_1111___0011_1111___0011_1111;

// These arrays contain numbers whose bits correspond to diagonals on the game board (excluding the current cell).
// It is an easy way to get diagonals containing the given cell.
pub const DIAGONALS: [u64; 64] = [
    0x8040201008040200,
    0x80402010080500,
    0x804020110a00,
    0x8041221400,
    0x182442800,
    0x10204885000,
    0x102040810a000,
    0x102040810204000,
    0x4020100804020002,
    0x8040201008050005,
    0x804020110a000a,
    0x804122140014,
    0x18244280028,
    0x1020488500050,
    0x102040810a000a0,
    0x204081020400040,
    0x2010080402000204,
    0x4020100805000508,
    0x804020110a000a11,
    0x80412214001422,
    0x1824428002844,
    0x102048850005088,
    0x2040810a000a010,
    0x408102040004020,
    0x1008040200020408,
    0x2010080500050810,
    0x4020110a000a1120,
    0x8041221400142241,
    0x182442800284482,
    0x204885000508804,
    0x40810a000a01008,
    0x810204000402010,
    0x804020002040810,
    0x1008050005081020,
    0x20110a000a112040,
    0x4122140014224180,
    0x8244280028448201,
    0x488500050880402,
    0x810a000a0100804,
    0x1020400040201008,
    0x402000204081020,
    0x805000508102040,
    0x110a000a11204080,
    0x2214001422418000,
    0x4428002844820100,
    0x8850005088040201,
    0x10a000a010080402,
    0x2040004020100804,
    0x200020408102040,
    0x500050810204080,
    0xa000a1120408000,
    0x1400142241800000,
    0x2800284482010000,
    0x5000508804020100,
    0xa000a01008040201,
    0x4000402010080402,
    0x2040810204080,
    0x5081020408000,
    0xa112040800000,
    0x14224180000000,
    0x28448201000000,
    0x50880402010000,
    0xa0100804020100,
    0x40201008040201,
];

pub const DIAGONALS_LIMITED_BY_2: [u64; 64] = [
    0x40200,
    0x80500,
    0x110a00,
    0x221400,
    0x442800,
    0x885000,
    0x10a000,
    0x204000,
    0x4020002,
    0x8050005,
    0x110a000a,
    0x22140014,
    0x44280028,
    0x88500050,
    0x10a000a0,
    0x20400040,
    0x402000204,
    0x805000508,
    0x110a000a11,
    0x2214001422,
    0x4428002844,
    0x8850005088,
    0x10a000a010,
    0x2040004020,
    0x40200020400,
    0x80500050800,
    0x110a000a1100,
    0x221400142200,
    0x442800284400,
    0x885000508800,
    0x10a000a01000,
    0x204000402000,
    0x4020002040000,
    0x8050005080000,
    0x110a000a110000,
    0x22140014220000,
    0x44280028440000,
    0x88500050880000,
    0x10a000a0100000,
    0x20400040200000,
    0x402000204000000,
    0x805000508000000,
    0x110a000a11000000,
    0x2214001422000000,
    0x4428002844000000,
    0x8850005088000000,
    0x10a000a010000000,
    0x2040004020000000,
    0x200020400000000,
    0x500050800000000,
    0xa000a1100000000,
    0x1400142200000000,
    0x2800284400000000,
    0x5000508800000000,
    0xa000a01000000000,
    0x4000402000000000,
    0x2040000000000,
    0x5080000000000,
    0xa110000000000,
    0x14220000000000,
    0x28440000000000,
    0x50880000000000,
    0xa0100000000000,
    0x40200000000000,
];
